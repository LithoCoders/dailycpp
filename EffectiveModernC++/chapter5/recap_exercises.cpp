#include <iostream>
#include <vector>
#include <array>
#include <string>
#include <cstring>

using namespace std;

void test1()
{
   string sOrig = "original";
   string sCopied = sOrig;

   cout << __func__ << "> orig: " << sOrig << endl;     // original
   cout << __func__ << "> copied: " << sCopied << endl; // original
}

void test2()
{
   string sOrig = "original";
   string & sCopied = sOrig;
   
   sOrig = "changed";

   cout << __func__ << "> orig: " << sOrig << endl;     // changed
   cout << __func__ << "> copied: " << sCopied << endl; // changed
}

void test3()
{
   string sOrig = "original";
   string sMoved = move(sOrig);
   
   sOrig = "changed";

   cout << __func__ << "> orig: " << sOrig << endl;    // changed
   cout << __func__ << "> copied: " << sMoved << endl; // original
}

void test4()
{
   string sOrig = "original";
   string sMoved = move(sOrig);

   cout << __func__ << "> orig: " << sOrig << endl;    // ""
   cout << __func__ << "> copied: " << sMoved << endl; // original
}

void test5()
{
   string sOrig = "original";
   string && sMoved = move(sOrig);
   
   sOrig = "changed";

   cout << __func__ << "> orig: " << sOrig << endl;    // changed
   cout << __func__ << "> copied: " << sMoved << endl; // changed
}

struct Tuna
{
    Tuna(const char * arr)
    {
        cout << "Tuna ctor" << endl;
        data = new char[256];
        strcpy(data, arr);
    }
    
    // ~Tuna()
    // {
    //     cout << "Tuna destructor" << endl;
    //     delete data;
    // }
    
    Tuna(const Tuna & other)
    {
        cout << "Tuna copy ctor" << endl;
        data = new char[256];
        strcpy(data, other.data);
    }
    
    char * data;
};

void test6()
{
   // enable Tuna constructor
   // enable ~Tuna()
   Tuna sOrig = "original";
   Tuna sMoved = sOrig; // Implicit (generated by compiler) copy constructor is called

   cout << __func__ << "> orig: " << sOrig.data << endl;    // original
   cout << __func__ << "> copied: " << sMoved.data << endl; // original
   
   // Memory corruption due to double deallocation 
   // Lesson: follow the rule of three
}

void test7()
{
   // enable Tuna constructor
   // enable ~Tuna()
   // enable Tuna copy ctor
   Tuna sOrig = "original"; // constructor is called
   Tuna sMoved = move(sOrig); // copy ctor is called

   cout << __func__ << "> orig: " << sOrig.data << endl;  // original
   cout << __func__ << "> moved: " << sMoved.data << endl; // original
}

void test8()
{
   // enable Tuna constructor
   // enable Tuna copy ctor
   Tuna sOrig = "original";  // ctor is called
   Tuna sCopied = move(sOrig); // copy ctor is called
   
   strcpy(sCopied.data, "changed");

   printf("address sOrig.data: %p\n", sOrig.data);    // one_x_address
   printf("address sMoved.data: %p\n", sCopied.data); // another_x_address
   
   cout << __func__ << "> orig: " << sOrig.data << endl;    // original
   cout << __func__ << "> moved: " << sCopied.data << endl; // changed
}

struct Tuna2
{
    Tuna2(const char * arg) : data(arg)
    {
        cout << "Tuna2 constructor" << endl;
    }
    
    // ~Tuna2()
    // {
    //     cout << "Tuna2 destructor" << endl;
    // }
    
    Tuna2(const Tuna2 & other)
    {
        cout << "Tuna2 copy constructor" << endl;
        data = other.data;
    }
    
    Tuna2(const Tuna2 && other)
    {
        cout << "Tuna2 move constructor" << endl;
        data = move(other.data);
    }
    
    string data;
};

void test9()
{
    // Enable only Tuna2 constructor
    Tuna2 sOrig = "original";
    Tuna2 sMoved = move(sOrig);  // implicit (generated by compiler) move ctor is called
    
    cout << __func__ << "> orig: " << sOrig.data << endl;    // ""
    cout << __func__ << "> copied: " << sMoved.data << endl; // "original"
}

void test10()
{
    // Enable Tuna2 constructor
    // Enable Tuna2 destructor
    Tuna2 sOrig = "original";   // ctor is called
    Tuna2 sMoved = move(sOrig); // implicit (generated by compiler) copy ctor is called
    
    cout << __func__ << "> orig: " << sOrig.data << endl;    // original
    cout << __func__ << "> copied: " << sMoved.data << endl; // original
}

void test11()
{
    // Enable Tuna2 constructor
    // Enable Tuna2 copy constructor
    vector<Tuna2> tuna_arr;
    Tuna2 item = "item";    // ctor is called
    
    tuna_arr.push_back(item);        // copy ctor is called
    tuna_arr.push_back(move(item));  // copy ctor + copy ctor are called
    
    for(const Tuna2 & it : tuna_arr)
    {
        cout << it.data << endl;
    }
    
    // cout will have: 
    // >> item
    // >> item
}

void test12()
{
    // Enable Tuna2 constructor
    // Enable Tuna2 copy constructor
    // Enable Tuna2 move constructor
    vector<Tuna2> tuna_arr;
    Tuna2 item = "item"; // ctor is called
    
     tuna_arr.push_back(item);        // copy ctor is called
     tuna_arr.push_back(move(item));  // move ctor + copy ctor are called
    
    for(const Tuna2 & it : tuna_arr)
    {
        cout << it.data << endl;
    }
    
    // cout will have: 
    // >> item
    // >> item
}

void test13()
{
    vector<string> source = { "Move", "iterators", "in", "C++" };
    vector<string> dest(begin(source), end(source));
    
    dest[0] = "changed";
    
    cout << "SOURCE: " << endl;
    for (const string & it : source)
    {
        cout << it << " AND ";
    }
    cout << endl;
    
    
    cout << "DESTINATION: " << endl;
    for (const string & it : dest)
    {
        cout << it << " ";
    }
    cout << endl;
    
    // cout will have:
    // >> SOURCE:                                                                                                                        
    // >> Move AND iterators AND in AND C++ AND                                                                                          
    // >> DESTINATION:                                                                                                                   
    // >> changed iterators in C++  
}

void test14()
{
    cout << __func__ << " > " << endl;
    
    vector<string> source = { "Move", "iterators", "in", "C++" };
    vector<string> dest(make_move_iterator(begin(source)),
                        make_move_iterator(end(source)));
    
    cout << "SOURCE: " << endl;
    for (const string & it : source)
    {
        cout << it << " AND ";
    }
    cout << endl;
    
    
    cout << "DESTINATION: " << endl;
    for (const string & it : dest)
    {
        cout << it << " ";
    }
    cout << endl;
    
    cout << __func__ << " < " << endl;
    
    // cout will have:
    // >> SOURCE:                                                                                                                        
    // >> "" AND "" AND "" AND "" AND                                                                                                            
    // >> DESTINATION:                                                                                                                   
    // >> Move iterators in C++  
}

void test15()
{
    cout << __func__ << " > " << endl;
    
    vector<string> source = { "Move", "iterators", "in", "C++" };
    vector<string> dest = move(source);
    
    cout << "SOURCE: " << endl;
    for (const string & it : source)
    {
        cout << it << " AND ";
    }
    cout << endl;
    
    cout << "DESTINATION: " << endl;
    for (const string & it : dest)
    {
        cout << it << " ";
    }
    cout << endl;
    
    cout << __func__ << " < " << endl;
    
    // cout will have:
    // >> SOURCE:                                                                                                                        
                                                                                                                                   
    // >> DESTINATION:                                                                                                                   
    // >> Move iterators in C++ 
}

int main()
{
	//test1(); cout << endl;
	//test2(); cout << endl;
	//test3(); cout << endl;
	//test4(); cout << endl;
	//test5(); cout << endl;
	//test6(); cout << endl;
	//test7(); cout << endl;
	//test8(); cout << endl;
	//test9(); cout << endl;
	//test10(); cout << endl;
	//test11(); cout << endl;
	//test12(); cout << endl;
	//test13(); cout << endl;
	//test14(); cout << endl;
	//test15(); cout << endl;
   
   	return 0;
}
